# PathBoolean uniteバグ：直近の明確な異変事実まとめ

## 1. テスト現象

- `test/PathBoolean.test.ts` の「重なる矩形のunite」テストが失敗する。
- 期待: 複合パス1つ（M0,0L100,0L100,50L150,50L150,150L50,150L50,100L0,100Z）
- 実際: 2つの矩形がそのまま（M0,0L100,0L100,100L0,100ZM50,50L150,50L150,150L50,150Z）

---

## 2. 直近の明確な異変事実

### 2.1 unite本体でのパス状態

- unite本体で_path2.getSegments()は常に[ [ 50, 50 ], [ 150, 50 ], [ 150, 150 ], [ 50, 150 ] ]（時計回り）で安定している。

### 2.2 getCurves()呼び出し時の異変

- unite本体で_path2.getCurves()を呼ぶと、segments配列の内容が[ [ 50, 50 ], [ 50, 150 ], [ 150, 150 ], [ 150, 50 ] ]（反時計回り）にズレているタイミングがある。
- つまり、**segments配列の先頭がreverseやreorientの副作用で回転し、時計回り→反時計回りにズレている**。

### 2.3 交点検出失敗の直接的な事実

- getCurves()のカーブ生成順がズレることで、交点検出ロジックが「矩形の辺同士が正しく重ならない」と判定し、交点が0個になる。
- そのため、unite結果が単なるCompoundPath（2つの矩形）となる。

---

## 3. 逆転現象の再現例

- Path.reverse()やsetClockwise、reorientの流れで、segments配列の先頭がreverse前とreverse後で異なる点になる場合がある。
- これにより、getCurves()のカーブ生成順が意図しない順序（反時計回り）になる。

---

## 4. 事実として確定していること

- unite本体で_path2.getSegments()は時計回りだが、getCurves()呼び出し時に反時計回りにズレている。
- これはreverseやreorientの副作用でsegments配列の先頭が回転しているため。
- 交点検出が失敗する直接の原因は「getCurves()のカーブ生成順が反時計回りになっていること」。

---

## 5. 仮説・推測は含めていない

- 上記は全てデバッグ出力やテスト実行結果から観測された「事実」のみ。
- 原因や修正方針の仮説は一切含めていない。